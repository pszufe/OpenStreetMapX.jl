var documenterSearchIndex = {"docs":
[{"location":"spatial/#Notes-on-spatial-data","page":"Notes on spatial data","title":"Notes on spatial data","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Using the the library makes basic understanding of spatial data. The following geographics coordinate systems are supported:","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Latitude-Longitude-Altitude (LLA)\nEarth-centered, Earth-fixed (ECEF)\nEast, North, Up (ENU)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"The LLA node is the standard way to represent locations. The ECEF and ENU modes uses a distance (measured in meters) from a reference point. To better understand those modes have a look at the Wikipedia pictures below:","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Earth-centered, Earth-fixed (ECEF)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"(Image: ECEF)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"East, North, Up (ENU)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"(Image: ENU)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Any point can be created using LLA struct: ","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"fields_institute_lla = LLA(43.658813, -79.397574, 0.0)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"LLA(43.658813, -79.397574, 0.0)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"The library enables conversion between diiferent coordinates systems. ","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"fields_ecef = OpenStreetMapX.ECEF(fields_institute_lla)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"ECEF(850365.5982110817, -4.542824565319083e6, 4.380743975743749e6)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Constructors for all-ways conversions are provided. ","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Once having a point it can be plotted (this requires installation of folium - see the README on the main project page):","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"\n\nusing PyCall\nflm = pyimport(\"folium\") #note that this requires folium to be installed\nm = flm.Map()\n\nflm.CircleMarker((fields_LLA.lat, fields_LLA.lon),\n        tooltip=\"Here is the Fields Institute\"\n    ).add_to(m)\nMAP_BOUNDS = [ Tuple(m.get_bounds()[1,:].-0.005), Tuple(m.get_bounds()[2,:].+0.005)]\n\n\nm.fit_bounds(MAP_BOUNDS)\n\nm","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = OpenStreetMapX\nDocTestSetup = quote\n    using OpenStreetMapX\nend","category":"page"},{"location":"reference/#Representing-map-data","page":"Reference","title":"Representing map data","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MapData\nget_map_data(::String,::Union{String,Nothing}; ::Set{Int},::Bool,::Bool)","category":"page"},{"location":"reference/#OpenStreetMapX.MapData","page":"Reference","title":"OpenStreetMapX.MapData","text":"The MapData represents all data that have been processed from OpenStreetMap osm file This is the main data structure used fot map data analytics.\n\nFields\n\nbounds :  bounds of the area map (stored as a OpenStreetMapX.Bounds object)\nnodes :  dictionary of nodes representing all the objects on the map (with coordinates in East, North, Up system)\nroadways :  unique roads stored as a OpenStreetMapX.Way objects\nintersections : roads intersections\ng : Graphs directed graph representing a road network\nv : vertices in the road network (node id .=> graph vertex)\nn : vector of OpenStreetMap node ids for each corresponding graph vertex\ne : vector of edges in the graph represented as a tuple (source,destination)\nw : sparse matrix of edge weights, indexed by graph id\nclass : road class of each edge\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.get_map_data-Tuple{String, Union{Nothing, String}}","page":"Reference","title":"OpenStreetMapX.get_map_data","text":"get_map_data(filepath::String,filename::Union{String,Nothing}=nothing;\n             road_levels::Set{Int} = Set(1:length(OpenStreetMapX.ROAD_CLASSES)),\n\t\t\t use_cache::Bool = true, only_intersections::Bool=true)::MapData\n\nHigh level function - parses .osm file and create the road network based on the map data. This code currently can parse both *.osm and *.pbf (@blegat - thank you!) files. The data type is determined by file extension.\n\nArguments\n\nfilepath : path with an .osm/.pbf file (directory or path to a file)\nfilename : name of the file (when the first argument is a directory)\nroad_levels : a set with the road categories (see: OpenStreetMapX.ROAD_CLASSES for more informations)\nuse_cache : a *.cache file will be crated with a serialized map image in the datapath folder\nonly_intersections : include only road system data\ntrim_to_connected_graph: trim orphan nodes in such way that the map is a strongly connected graph\n\n\n\n\n\n","category":"method"},{"location":"reference/#Coordinate-systems","page":"Reference","title":"Coordinate systems","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"ECEF\nLLA\nENU\nBounds\ncenter\ninbounds\nonbounds\nlatlon","category":"page"},{"location":"reference/#OpenStreetMapX.ECEF","page":"Reference","title":"OpenStreetMapX.ECEF","text":"ECEF\n\nPoint in Earth-Centered-Earth-Fixed (ECEF) coordinates. Global cartesian coordinate system rotating with the Earth.\n\nConstructors\n\nECEF(x::Float64, y::Float64, z::Float64)\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.LLA","page":"Reference","title":"OpenStreetMapX.LLA","text":"LLA\n\nPoint in Latitude-Longitude-Altitude (LLA) coordinates Used to store node data in OpenStreetMapX XML files\n\nConstructors\n\nLLA(lat::Float64, lon::Float64)\nLLA(lat::Float64, lon::Float64, alt::Float64)\nLLA(xyz::XYZ)\n\nArguments\n\nlat : lattitude\nlon : Longitude\nalt : altitude\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.ENU","page":"Reference","title":"OpenStreetMapX.ENU","text":"ENU\n\nPoint in East-North-Up (ENU) coordinates.\n\nLocal cartesian coordinate system. Linearized about a reference point.\n\nConstructors\n\nENU(east::Float64, north::Float64, up::Float64)\nENU(east::Float64, north::Float64)\nENU(xyz::XYZ)\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.Bounds","page":"Reference","title":"OpenStreetMapX.Bounds","text":"Bounds{T <: Union{LLA, ENU}}\n\nBounds for the LLA or ENUcoordinates. If T is not given Bounds{ENU} will be created.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.center","page":"Reference","title":"OpenStreetMapX.center","text":"center(bounds::Bounds{ENU})\n\nGet Center Point of ENU Bounds Region\n\n\n\n\n\ncenter(bounds::Bounds{LLA})\n\nGet Center Point of LLA Bounds Region\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.inbounds","page":"Reference","title":"OpenStreetMapX.inbounds","text":"inbounds(loc::ENU, bounds::Bounds{ENU})\n\nCheck Whether a location loc is within bounds bounds\n\n\n\n\n\ninbounds(loc::LLA, bounds::Bounds{LLA})\n\nCheck whether a location loc is within bounds bounds\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.onbounds","page":"Reference","title":"OpenStreetMapX.onbounds","text":"onbounds(loc::T, bounds::Bounds{T}) where T<:Union{LLA,ENU}\n\nCheck whether a location loc is onbounds bounds Works only for points that have passed the inbounds test\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.latlon","page":"Reference","title":"OpenStreetMapX.latlon","text":"latlon(m::MapData,map_g_point_id::Int64)::Tuple{Float64, Float64}\n\nReturns a tuple of lattitute and longitude for a given graph node identifier map_g_point_id in graph m.g (i.e. map_g_point_id âˆˆ 1:nv(m.g)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#Routing-operations","page":"Reference","title":"Routing operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"generate_point_in_bounds(::MapData)\npoint_to_nodes(::Tuple{Float64,Float64}, ::MapData)\npoint_to_nodes(::LLA, ::MapData)\nshortest_route\nfastest_route\na_star_algorithm\ndistance","category":"page"},{"location":"reference/#OpenStreetMapX.point_to_nodes-Tuple{Tuple{Float64, Float64}, MapData}","page":"Reference","title":"OpenStreetMapX.point_to_nodes","text":"point_to_nodes(point::Tuple{Float64,Float64}, m::MapData)\n\nConverts a pair Latitude-Longitude of coordinates point to a node on a map m The result is a node indentifier.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.point_to_nodes-Tuple{LLA, MapData}","page":"Reference","title":"OpenStreetMapX.point_to_nodes","text":"point_to_nodes(point::LLA, m::MapData)\n\nConverts a pair of coordinates LLA (Latitude-Longitude-Altitude) point to a node on a map m The result is a node indentifier.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.shortest_route","page":"Reference","title":"OpenStreetMapX.shortest_route","text":"shortest_route(m::MapData, node1::Int, node2::Int; routing::Symbol = :astar)\n\nFind Shortest route between node1 and node2 on map m.\n\n\n\n\n\nshortest_route(m::MapData, node1::Int, node2::Int, node3::Int; routing::Symbol = :astar)\n\nFind Shortest route between node1 and node2 and node3 on map m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.fastest_route","page":"Reference","title":"OpenStreetMapX.fastest_route","text":"fastest_route(m::MapData, node1::Int, node2::Int;\n                    routing::Symbol = :astar,\n                    speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)\n\nFind fastest route between node1 and node2  on map m with assuming speeds for road classes.\n\n\n\n\n\nfastest_route(m::MapData, node1::Int, node2::Int, node3::Int;\n                    routing::Symbol = :astar,\n                    speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)\n\nFind fastest route between node1 and node2 and node3  on map m with assuming speeds for road classes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.a_star_algorithm","page":"Reference","title":"OpenStreetMapX.a_star_algorithm","text":"a_star_algorithm(g::AbstractGraph{U},  \n                s::Integer,                       \n                t::Integer,                       \n                distmx::AbstractMatrix{T}=Graphs.weights(g),\n                heuristic::Function = (u,v) -> zero(T)) where {T, U}\n\nHigh level function - implementation of A star search algorithm: (https://en.wikipedia.org/wiki/A*searchalgorithm).  Based on the implementation in Graphs library,  however significantly improved in terms of performance.\n\nArguments\n\ng : graph object\nS : start vertex\nt : end vertex\ndistmx : distance matrix\nheuristic : search heuristic function; by default returns zero \n\n\n\n\n\na_star_algorithm(m::MapData,  \n                s::Integer,                       \n                t::Integer)\n\nA star search algorithm with straight line distance heuristic\n\nArguments\n\nm : MapData object\nS : start vertex\nt : end vertex\ndistmx : distance matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.distance","page":"Reference","title":"OpenStreetMapX.distance","text":"distance(a::ENU, b::ENU)\n\nCalculates a distance between two points a and b\n\n\n\n\n\ndistance(a::ECEF, b::ECEF)\n\nCalculates a distance between two points a and b\n\n\n\n\n\nCompute the distance of a route for some nodes data\n\n\n\n\n\nGet Distances Between Edges\n\n\n\n\n\n","category":"function"},{"location":"reference/#Google-API-routing","page":"Reference","title":"Google API routing","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"get_google_route(::Int,::Int,::MapData,::String; ::Dict{Symbol,String})\nget_google_route(::Int,::Int,::Int,::MapData,::String; ::Dict{Symbol,String})\nnode_to_string(::Int,::MapData)\ngoogleAPI_parameters\nencode_one\nencode\ndecode_one\ndecode","category":"page"},{"location":"reference/#OpenStreetMapX.get_google_route-Tuple{Int64, Int64, MapData, String}","page":"Reference","title":"OpenStreetMapX.get_google_route","text":"get_google_route(origin::Int, destination::Int,\n                 map_data:MapData, googleapi_key::String;\n                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)\n\nGet route from to based on Google Distances API with two points (origin and destination) on map map_data using Google API key googleapi_key with optional Google Distances API request parameters googleapi_parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.get_google_route-Tuple{Int64, Int64, Int64, MapData, String}","page":"Reference","title":"OpenStreetMapX.get_google_route","text":"get_google_route(origin::Int, destination::Int, waypoint::Int,\n                 map_data:MapData, googleapi_key::String;\n                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)\n\nGet route from to based on Google Distances API with three points (origin, destination and waypoint between) on map map_data using Google API key googleapi_key with optional Google Distances API request parameters googleapi_parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.node_to_string-Tuple{Int64, MapData}","page":"Reference","title":"OpenStreetMapX.node_to_string","text":"node_to_string(node_id::Int,map_data::MapData)\n\nConvert node coordinates (stored in ENU system in the nodes field of map_data) identified by node_id to string with LLA system coordinates\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.googleAPI_parameters","page":"Reference","title":"OpenStreetMapX.googleAPI_parameters","text":"Dictionary for Google Distances API requests:\n\nKeys\n\n:url : url for google API, only JSON files outputs are accepted\n:mode : transportation mode used in simulation, in the current library scope only driving is accepted\n:avoid : map features to avoid (to mantain compatibility with OSM routes ferries should be avoided)\n:units : unit system for displaing distances (changing to imperial needs deeper changes in both OSMsim and OpenStreetMapX modules)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.encode_one","page":"Reference","title":"OpenStreetMapX.encode_one","text":"Encode single coordinate (multiplied by 1e5 and rounded) in Google Polyline Algorithm Format\n\nArguments\n\nval : single coordinate (multiplied by 1e5 and rounded)\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.encode","page":"Reference","title":"OpenStreetMapX.encode","text":"Encode coordinates in Google Polyline Algorithm Format\n\nArguments\n\ncoords : coordinates in LLA system stored as a tuple\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.decode_one","page":"Reference","title":"OpenStreetMapX.decode_one","text":"Decode single coordinate\n\nArguments\n\npolyline : coordinates in Google Polyline Algorithm Format stored as an array of characters\nindex : position of each single coordinate in polyline array\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.decode","page":"Reference","title":"OpenStreetMapX.decode","text":"Decode coordinates in Google Polyline Algorithm Format\n\nArguments\n\npolyline : string containing coordinates in Polyline Algorithm Format\n\n\n\n\n\n","category":"function"},{"location":"reference/#Routing-parameters","page":"Reference","title":"Routing parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"ROAD_CLASSES\nCYCLE_CLASSES\nPED_CLASSES\nSPEED_ROADS_URBAN\nSPEED_ROADS_RURAL","category":"page"},{"location":"reference/#OpenStreetMapX.ROAD_CLASSES","page":"Reference","title":"OpenStreetMapX.ROAD_CLASSES","text":"ROAD_CLASSES\n\nRoad classes. Information used for routing and plotting.\n\nOrdered by typical significance\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.CYCLE_CLASSES","page":"Reference","title":"OpenStreetMapX.CYCLE_CLASSES","text":"CYCLE_CLASSES\n\nCycle classes \t- Level 1: Bike paths \t- Level 2: Separated bike lanes (tracks) \t- Level 3: Bike lanes \t- Level 4: Bikes typically allowed but not specified\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.PED_CLASSES","page":"Reference","title":"OpenStreetMapX.PED_CLASSES","text":"PED_CLASSES\n\nPedestrain paths\n\n- Level 1: Cycleways, walking paths, and pedestrian streets\n- Level 2: Sidewalks\n- Level 3: Pedestrians typically allowed but unspecified\n- Level 4: Agricultural or horse paths, etc.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.SPEED_ROADS_URBAN","page":"Reference","title":"OpenStreetMapX.SPEED_ROADS_URBAN","text":"Default Speed Limits in Kilometers Per Hour in urban areas\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.SPEED_ROADS_RURAL","page":"Reference","title":"OpenStreetMapX.SPEED_ROADS_RURAL","text":"Default Speed Limits in Kilometers Per Hour in rural areas\n\n\n\n\n\n","category":"constant"},{"location":"#OpenStreetMapX.jl","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"","category":"section"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"Documentation for OpenStreetMapX.jl","category":"page"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"For details please go to the Reference section.","category":"page"},{"location":"#Package-features","page":"OpenStreetMapX.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"Parse an OpenStreetMap XML datafile (OSM files)\nCrop maps to specified boundaries\nConvert maps between LLA, ECEF, and ENU coordinates\nExtract highways, buildings, and tagged features from OSM data\nCompute shortest or fastest driving, cycling, and walking routes using Julia's LightGraphs.jl package including various systems for weighting travel speed\nUse OpenStreetMapXPlot to draw maps using either Julia's PyPlot.jl or Plots.jl with GR backend packages\nIntegrate with Python folium (via PyCall.jl) to create interactive map plots","category":"page"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"For details please go to the Reference section.","category":"page"}]
}
