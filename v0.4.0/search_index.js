var documenterSearchIndex = {"docs":
[{"location":"spatial/#Notes-on-spatial-data","page":"Notes on spatial data","title":"Notes on spatial data","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Using the the library makes basic understanding of spatial data. The following geographics coordinate systems are supported:","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Latitude-Longitude-Altitude (LLA)\nEarth-centered, Earth-fixed (ECEF)\nEast, North, Up (ENU)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"The LLA node is the standard way to represent locations. The latitude is the angle between the equatorial plane and the straight line that passes through that point and through (or close to) the center of the Earth. The longitude is the angle east or west of a reference meridian to another meridian that passes through that point. The altitude is the height of a point in relation to sea level or ground level.","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"The ECEF and ENU modes uses a distance (measured in meters) from a reference point. The ECEF mode is a cartesian spatial reference system that represents locations in the vicinity of the Earth as X, Y, and Z measurements from its point of origin. The ECEF that is used for the Global Positioning System (GPS) is the geocentric WGS 84, which currently includes its own ellipsoid definition. The ENU mode is far more intuitive and practical than ECEF or Geodetic coordinates. The local ENU coordinates are formed from a plane tangent to the Earth's surface fixed to a specific location.","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"To better understand those modes have a look at the Wikipedia pictures below:","category":"page"},{"location":"spatial/#Earth-centered,-Earth-fixed-(ECEF)","page":"Notes on spatial data","title":"Earth-centered, Earth-fixed (ECEF)","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"The point (0,0,0) denotes the centre of the Earth (hence the name 'Earth-Centred') and the system rotates in solidarity with the Earth. The X-Y plane is coincident with the equatorial plane with the respective versors pointing in the directions of longitude 0° and 90°, while the Z-axis orthogonal to this plane points in the direction of the North Pole. The X,Y,Z coordinates are represented in metres. ECEF coordinates are used in the GPS positioning system, as they are considered to be the conventional earth reference system.","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"(Image: ECEF)","category":"page"},{"location":"spatial/#East,-North,-Up-(ENU)","page":"Notes on spatial data","title":"East, North, Up (ENU)","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"These references are location-dependent. For movements across the globe, such as air or sea navigation, the references are defined as tangents to the lines of geographical coordinates:","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"East-west axis, that is tangent to parallels,\nNorth-south axis, that is tangent to meridians, and\nUp-down axis in the direction normal to the oblate spheroid used as Earth's ellipsoid, which generally does not pass through the center of the Earth.","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"(Image: ENU)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"In this library, any point can be created using LLA struct: ","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"fields_institute_lla = LLA(43.658813, -79.397574, 0.0)","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"LLA(43.658813, -79.397574, 0.0)","category":"page"},{"location":"spatial/#Examples","page":"Notes on spatial data","title":"Examples","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"conversion between different coordinates systems.","category":"page"},{"location":"spatial/#Constructors-for-conversions","page":"Notes on spatial data","title":"Constructors for conversions","text":"","category":"section"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"    # From LLA to ECEF\n    ECEF(lla::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ECEF to LLA\n    LLA(ecef::ECEF, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ECEF with LLA reference point to ENU\n    ENU(ecef::ECEF, lla_ref::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ECEF with Bound reference point to ENU\n    ENU(ecef::ECEF, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU with LLA reference point to ECEF\n    ECEF(enu::ENU, lla_ref::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU with Bound reference point to ECEF\n    ECEF(enu::ENU, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From LLA with LLA reference point to ENU\n    ENU(lla::LLA, lla_ref::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From LLA with Bound reference point to ENU\n    ENU(lla::LLA, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU with LLA reference point to LLA\n    LLA(enu::ENU, lla_ref::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU with Bound reference point to LLA\n    LLA(enu::ENU, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From LLA's dict to ECEF's dict\n    ECEF(nodes::Dict{Int,LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ECEF's dict to LLA's dict\n    LLA(nodes::Dict{Int,ECEF}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From LLA or ECEF with LLA reference point to ENU's dict\n    ENU(nodes::Dict{Int,T}, lla_ref::LLA, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84) where T<:Union{LLA,ECEF}\n\n    # From LLA or ECEF with Bound reference point to ENU's dict\n    ENU(nodes::Dict{Int,T}, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84) where T<:Union{LLA,ECEF}\n\n    # From ENU's dict to ECEF's dict with LLA reference point\n    ECEF(nodes::Dict{Int,ENU},lla_ref::LLA , datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU's dict to ECEF's dict with Bound reference point\n    ECEF(nodes::Dict{Int,ENU}, bounds::Bounds{LLA},datum::Ellipsoid = WGS84)\n\n    # From ENU's dict to LLA's dict with LLA reference point\n    LLA(nodes::Dict{Int,ENU},lla_ref::LLA , datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n\n    # From ENU's dict to LLA's dict with Bound reference point\n    LLA(nodes::Dict{Int,ENU}, bounds::Bounds{LLA}, datum::OpenStreetMapX.Ellipsoid = OpenStreetMapX.WGS84)\n","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"Once having a point it can be plotted (this requires installation of folium - see the README on the main project page):","category":"page"},{"location":"spatial/","page":"Notes on spatial data","title":"Notes on spatial data","text":"using PyCall\nflm = pyimport(\"folium\") #note that this requires folium to be installed\nm = flm.Map()\n\nflm.CircleMarker((fields_LLA.lat, fields_LLA.lon),\n        tooltip=\"Here is the Fields Institute\"\n    ).add_to(m)\nMAP_BOUNDS = [ Tuple(m.get_bounds()[1,:].-0.005), Tuple(m.get_bounds()[2,:].+0.005)]\n\n\nm.fit_bounds(MAP_BOUNDS)\n\nm","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = OpenStreetMapX\nDocTestSetup = quote\n    using OpenStreetMapX\nend","category":"page"},{"location":"reference/#Representing-map-data","page":"Reference","title":"Representing map data","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"MapData\nget_map_data(::String,::Union{String,Nothing}; ::Set{Int},::Bool,::Bool)\nsample_map_path\nsample_map","category":"page"},{"location":"reference/#OpenStreetMapX.MapData","page":"Reference","title":"OpenStreetMapX.MapData","text":"The MapData represents all data that have been processed from OpenStreetMap osm file This is the main data structure used fot map data analytics.\n\nFields\n\nbounds :  bounds of the area map (stored as a Bounds object)\nnodes :  dictionary of nodes representing all the objects on the map (with coordinates in East, North, Up system)\nroadways :  unique roads stored as a set of Ways\nintersections : roads intersections\ng : Graphs directed graph representing a road network\nv : vertices in the road network (node id .=> graph vertex)\nn : vector of OpenStreetMap node ids for each corresponding graph vertex\ne : vector of edges in the graph represented as a tuple (source,destination)\nw : sparse matrix of edge weights, indexed by graph id\nclass : road class of each edge\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.get_map_data-Tuple{String, Union{Nothing, String}}","page":"Reference","title":"OpenStreetMapX.get_map_data","text":"get_map_data(filepath::String,filename::Union{String,Nothing}=nothing;\n             road_levels::Set{Int} = Set(1:length(OpenStreetMapX.ROAD_CLASSES)),\n\t\t\t use_cache::Bool = true, only_intersections::Bool=true)::MapData\n\nHigh level function - parses .osm file and create the road network based on the map data. This code currently can parse both *.osm and *.pbf (@blegat - thank you!) files. The data type is determined by file extension.\n\nArguments\n\nfilepath : path with an .osm/.pbf file (directory or path to a file)\nfilename : name of the file (when the first argument is a directory)\nroad_levels : a set with the road categories (see: OpenStreetMapX.ROAD_CLASSES for more informations)\nuse_cache : a *.cache file will be crated with a serialized map image in the datapath folder\nonly_intersections : include only road system data\ntrim_to_connected_graph: trim orphan nodes in such way that the map is a strongly connected graph\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.sample_map_path","page":"Reference","title":"OpenStreetMapX.sample_map_path","text":"sample_map_path()\n\nProduces a path to a sample map file.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.sample_map","page":"Reference","title":"OpenStreetMapX.sample_map","text":"sample_map()\n\nProduces a MapData object in a lazy loaded way.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Coordinate-systems","page":"Reference","title":"Coordinate systems","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"ECEF\nLLA\nENU\nBounds\ncenter\ninbounds\nonbounds\nlatlon\ngetX\ngetY\ngetZ\nWGS84","category":"page"},{"location":"reference/#OpenStreetMapX.ECEF","page":"Reference","title":"OpenStreetMapX.ECEF","text":"ECEF\n\nPoint in Earth-Centered-Earth-Fixed (ECEF) coordinates. Global cartesian coordinate system rotating with the Earth.\n\nConstructors\n\nECEF(x::Float64, y::Float64, z::Float64)\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.LLA","page":"Reference","title":"OpenStreetMapX.LLA","text":"LLA\n\nPoint in Latitude-Longitude-Altitude (LLA) coordinates Used to store node data in OpenStreetMapX XML files\n\nConstructors\n\nLLA(lat::Float64, lon::Float64)\nLLA(lat::Float64, lon::Float64, alt::Float64)\nLLA(xyz::XYZ)\n\nArguments\n\nlat : lattitude\nlon : Longitude\nalt : altitude\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.ENU","page":"Reference","title":"OpenStreetMapX.ENU","text":"ENU\n\nPoint in East-North-Up (ENU) coordinates.\n\nLocal cartesian coordinate system. Linearized about a reference point.\n\nConstructors\n\nENU(east::Float64, north::Float64, up::Float64)\nENU(east::Float64, north::Float64)\nENU(xyz::XYZ)\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.Bounds","page":"Reference","title":"OpenStreetMapX.Bounds","text":"Bounds{T <: Union{LLA, ENU}}\n\nBounds for the LLA or ENUcoordinates. If T is not given Bounds{ENU} will be created.\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.center","page":"Reference","title":"OpenStreetMapX.center","text":"center(bounds::Bounds{ENU})\n\nGet Center Point of ENU Bounds Region\n\n\n\n\n\ncenter(bounds::Bounds{LLA})\n\nGet Center Point of LLA Bounds Region\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.inbounds","page":"Reference","title":"OpenStreetMapX.inbounds","text":"inbounds(loc::ENU, bounds::Bounds{ENU})\n\nCheck Whether a location loc is within bounds bounds\n\n\n\n\n\ninbounds(loc::LLA, bounds::Bounds{LLA})\n\nCheck whether a location loc is within bounds bounds\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.onbounds","page":"Reference","title":"OpenStreetMapX.onbounds","text":"onbounds(loc::T, bounds::Bounds{T}) where T<:Union{LLA,ENU}\n\nCheck whether a location loc is onbounds bounds Works only for points that have passed the inbounds test\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.latlon","page":"Reference","title":"OpenStreetMapX.latlon","text":"latlon(m::MapData,map_g_point_id::Int64)::Tuple{Float64, Float64}\n\nReturns a tuple of lattitute and longitude for a given graph node identifier map_g_point_id in graph m.g (i.e. map_g_point_id ∈ 1:nv(m.g)).\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.getX","page":"Reference","title":"OpenStreetMapX.getX","text":"getX(lla::OpenStreetMapX.LLA)\n\nPoint Translator gets longitude\n\n\n\n\n\ngetX(enu::OpenStreetMapX.ENU)\n\nPoint Translator gets enu east value\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.getY","page":"Reference","title":"OpenStreetMapX.getY","text":"getY(lla::OpenStreetMapX.LLA)\n\nPoint Translator gets lattitude\n\n\n\n\n\ngetY(enu::OpenStreetMapX.ENU)\n\nPoint Translator gets enu north value\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.getZ","page":"Reference","title":"OpenStreetMapX.getZ","text":"getZ(lla::OpenStreetMapX.LLA)\n\nPoint Translator gets altitude\n\n\n\n\n\ngetZ(enu::OpenStreetMapX.ENU)\n\nPoint Translator gets up value\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.WGS84","page":"Reference","title":"OpenStreetMapX.WGS84","text":"World Geodetic Coordinate System of 1984 (WGS 84) Standardized coordinate system for Earth Global ellipsoidal reference surface\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Routing-operations","page":"Reference","title":"Routing operations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"generate_point_in_bounds\npoint_to_nodes(::Tuple{Float64,Float64}, ::MapData)\npoint_to_nodes(::LLA, ::MapData)\nshortest_route\nfastest_route\na_star_algorithm\ndistance\nget_distance\nnodes_within_driving_time\nnodes_within_driving_distance\nnodes_within_weights\nnearest_node\nnodes_within_range","category":"page"},{"location":"reference/#OpenStreetMapX.generate_point_in_bounds","page":"Reference","title":"OpenStreetMapX.generate_point_in_bounds","text":"generate_point_in_bounds([rng::AbstractRNG], m::MapData)\n\nGenerates a random pair of Latitude-Longitude coordinates within boundaries of map m\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.point_to_nodes-Tuple{Tuple{Float64, Float64}, MapData}","page":"Reference","title":"OpenStreetMapX.point_to_nodes","text":"point_to_nodes(point::Tuple{Float64,Float64}, m::MapData)\n\nConverts a pair Latitude-Longitude of coordinates point to a node on a map m The result is a node indentifier.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.point_to_nodes-Tuple{LLA, MapData}","page":"Reference","title":"OpenStreetMapX.point_to_nodes","text":"point_to_nodes(point::LLA, m::MapData)\n\nConverts a pair of coordinates LLA (Latitude-Longitude-Altitude) point to a node on a map m The result is a node indentifier.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.shortest_route","page":"Reference","title":"OpenStreetMapX.shortest_route","text":"shortest_route(m::MapData, node1::Int, node2::Int; routing::Symbol = :astar)\n\nFind Shortest route between node1 and node2 on map m.\n\n\n\n\n\nshortest_route(m::MapData, node1::Int, node2::Int, node3::Int; routing::Symbol = :astar)\n\nFind Shortest route between node1 and node2 and node3 on map m.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.fastest_route","page":"Reference","title":"OpenStreetMapX.fastest_route","text":"fastest_route(m::MapData, node1::Int, node2::Int;\n                    routing::Symbol = :astar,\n                    speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)\n\nFind fastest route between node1 and node2  on map m with assuming speeds for road classes.\n\n\n\n\n\nfastest_route(m::MapData, node1::Int, node2::Int, node3::Int;\n                    routing::Symbol = :astar,\n                    speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)\n\nFind fastest route between node1 and node2 and node3  on map m with assuming speeds for road classes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.a_star_algorithm","page":"Reference","title":"OpenStreetMapX.a_star_algorithm","text":"a_star_algorithm(g::AbstractGraph{U},  \n                s::Integer,                       \n                t::Integer,                       \n                distmx::AbstractMatrix{T}=Graphs.weights(g),\n                heuristic::Function = (u,v) -> zero(T)) where {T, U}\n\nHigh level function - implementation of A star search algorithm: (https://en.wikipedia.org/wiki/A*searchalgorithm).  Based on the implementation in Graphs library,  however significantly improved in terms of performance.\n\nArguments\n\ng : graph object\nS : start vertex\nt : end vertex\ndistmx : distance matrix\nheuristic : search heuristic function; by default returns zero \n\n\n\n\n\na_star_algorithm(m::MapData,  \n                s::Integer,                       \n                t::Integer)\n\nA star search algorithm with straight line distance heuristic\n\nArguments\n\nm : MapData object\nS : start vertex\nt : end vertex\ndistmx : distance matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.distance","page":"Reference","title":"OpenStreetMapX.distance","text":"distance(a::ENU, b::ENU)\n\nCalculates a distance between two points a and b\n\n\n\n\n\ndistance(a::ECEF, b::ECEF)\n\nCalculates a distance between two points a and b\n\n\n\n\n\ndistance(x1, y1, z1, x2, y2, z2)\n\nCalculates eclidean distance in three dimensions.\n\n\n\n\n\ndistance(nodes::Dict{Int,T}, route::AbstractVector{Int}) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nCompute the distance of a route for some nodes data\n\n\n\n\n\nGet Distances Between Edges\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.get_distance","page":"Reference","title":"OpenStreetMapX.get_distance","text":"get_distance(A::Int, B::Int, \n             nodes::Dict{Int,T} , \n             vertices_to_nodes::Vector{Int}) where T<:Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF}\n\nAuxiliary function - takes two vertices of graph and return the distance between them.  Used to compute straight line distance heuristic for A* algorithm.\n\nArguments\n\nA : start vertex\nB : end vertex\nnodes : dictionary of .osm nodes ID's and correspoding points coordinates\nvertices_to_nodes : dictionary mapping graph vertices to .osm file nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.nodes_within_driving_time","page":"Reference","title":"OpenStreetMapX.nodes_within_driving_time","text":"nodes_within_driving_time(m::MapData, start_indices::Vector{Int}, limit::Float64=Inf, speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN)\n\nnodes_within_driving_time(nodes::Dict{Int,T}, m::MapData, loc::T, limit::Float64=Inf, locrange::Float64=500.0, speeds::Dict{Int,Float64}=SPEED_ROADS_URBAN) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nExtract Nodes from bellman_fordStates Object Within an (Optional) Limit ### Based on Driving Time\t\t\t\t\t\t\t\t\t\t\t\t   ###\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.nodes_within_driving_distance","page":"Reference","title":"OpenStreetMapX.nodes_within_driving_distance","text":"nodes_within_driving_distance(m::MapData, start_indices::Vector{Int}, limit::Float64=Inf)\n\nExtract Nodes from bellman_fordStates Object Within an (Optional) Limit ### Based on Driving Distance\t\t\t\t\t\t\t\t\t\t\t   ###\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.nodes_within_weights","page":"Reference","title":"OpenStreetMapX.nodes_within_weights","text":"nodes_within_weights(m::MapData, weights::SparseArrays.SparseMatrixCSC{Float64,Int64}, start_indices::Vector{Int}, limit::Float64=Inf)\n\nExtract Nodes from bellman_fordStates Object Within an (Optional) Limit ### Based on Weights\t\t\t\t\t\t\t\t\t\t\t\t\t   ###\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.nearest_node","page":"Reference","title":"OpenStreetMapX.nearest_node","text":"nearest_node(nodes::Dict{Int,T}, loc::T) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nFind the nearest node to a given location loc\n\n\n\n\n\nnearest_node(m::MapData, loc::ENU, vs_only::Bool=true)\n\nFind the nearest node to a given location loc\n\n\n\n\n\nnearest_node(nodes::Dict{Int,T}, loc::T, node_list::AbstractSet{Int}) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nFind the nearest node in a list of nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.nodes_within_range","page":"Reference","title":"OpenStreetMapX.nodes_within_range","text":"nodes_within_range(nodes::Dict{Int,T}, loc::T, range::Float64 = Inf) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nFind all nodes within range of a location\n\n\n\n\n\nnodes_within_range(nodes::Dict{Int,T}, loc::T, node_list::AbstractSet{Int}, range::Float64 = Inf) where T<:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nFind nodes within range of a location using a subset of nodes\n\n\n\n\n\nnodes_within_range(nodes::Dict{Int,T},loc::T, m::OpenStreetMapX.MapData, range::Float64 = Inf) where T <:(Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF})\n\nFind vertices of a routing network within range of a location\n\n\n\n\n\n","category":"function"},{"location":"reference/#Google-API-routing","page":"Reference","title":"Google API routing","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"get_google_route(::Int,::Int,::MapData,::String; ::Dict{Symbol,String})\nget_google_route(::Int,::Int,::Int,::MapData,::String; ::Dict{Symbol,String})\nnode_to_string(::Int,::MapData)\ngoogleAPI_parameters\nencode_one\nencode\ndecode_one\ndecode","category":"page"},{"location":"reference/#OpenStreetMapX.get_google_route-Tuple{Int64, Int64, MapData, String}","page":"Reference","title":"OpenStreetMapX.get_google_route","text":"get_google_route(origin::Int, destination::Int,\n                 map_data:MapData, googleapi_key::String;\n                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)\n\nGet route from to based on Google Distances API with two points (origin and destination) on map map_data using Google API key googleapi_key with optional Google Distances API request parameters googleapi_parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.get_google_route-Tuple{Int64, Int64, Int64, MapData, String}","page":"Reference","title":"OpenStreetMapX.get_google_route","text":"get_google_route(origin::Int, destination::Int, waypoint::Int,\n                 map_data:MapData, googleapi_key::String;\n                 googleapi_parameters::Dict{Symbol,String} = googleAPI_parameters)\n\nGet route from to based on Google Distances API with three points (origin, destination and waypoint between) on map map_data using Google API key googleapi_key with optional Google Distances API request parameters googleapi_parameters.\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.node_to_string-Tuple{Int64, MapData}","page":"Reference","title":"OpenStreetMapX.node_to_string","text":"node_to_string(node_id::Int,map_data::MapData)\n\nConvert node coordinates (stored in ENU system in the nodes field of map_data) identified by node_id to string with LLA system coordinates\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenStreetMapX.googleAPI_parameters","page":"Reference","title":"OpenStreetMapX.googleAPI_parameters","text":"Dictionary for Google Distances API requests:\n\nKeys\n\n:url : url for google API, only JSON files outputs are accepted\n:mode : transportation mode used in simulation, in the current library scope only driving is accepted\n:avoid : map features to avoid (to mantain compatibility with OSM routes ferries should be avoided)\n:units : unit system for displaing distances (changing to imperial needs deeper changes in both OSMsim and OpenStreetMapX modules)\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.encode_one","page":"Reference","title":"OpenStreetMapX.encode_one","text":"Encode single coordinate (multiplied by 1e5 and rounded) in Google Polyline Algorithm Format\n\nArguments\n\nval : single coordinate (multiplied by 1e5 and rounded)\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.encode","page":"Reference","title":"OpenStreetMapX.encode","text":"Encode coordinates in Google Polyline Algorithm Format\n\nArguments\n\ncoords : coordinates in LLA system stored as a tuple\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.decode_one","page":"Reference","title":"OpenStreetMapX.decode_one","text":"Decode single coordinate\n\nArguments\n\npolyline : coordinates in Google Polyline Algorithm Format stored as an array of characters\nindex : position of each single coordinate in polyline array\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.decode","page":"Reference","title":"OpenStreetMapX.decode","text":"Decode coordinates in Google Polyline Algorithm Format\n\nArguments\n\npolyline : string containing coordinates in Polyline Algorithm Format\n\n\n\n\n\n","category":"function"},{"location":"reference/#Routing-parameters","page":"Reference","title":"Routing parameters","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"ROAD_CLASSES\nCYCLE_CLASSES\nPED_CLASSES\nSPEED_ROADS_URBAN\nSPEED_ROADS_RURAL","category":"page"},{"location":"reference/#OpenStreetMapX.ROAD_CLASSES","page":"Reference","title":"OpenStreetMapX.ROAD_CLASSES","text":"ROAD_CLASSES\n\nRoad classes. Information used for routing and plotting.\n\nOrdered by typical significance\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.CYCLE_CLASSES","page":"Reference","title":"OpenStreetMapX.CYCLE_CLASSES","text":"CYCLE_CLASSES\n\nCycle classes \t- Level 1: Bike paths \t- Level 2: Separated bike lanes (tracks) \t- Level 3: Bike lanes \t- Level 4: Bikes typically allowed but not specified\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.PED_CLASSES","page":"Reference","title":"OpenStreetMapX.PED_CLASSES","text":"PED_CLASSES\n\nPedestrain paths\n\n- Level 1: Cycleways, walking paths, and pedestrian streets\n- Level 2: Sidewalks\n- Level 3: Pedestrians typically allowed but unspecified\n- Level 4: Agricultural or horse paths, etc.\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.SPEED_ROADS_URBAN","page":"Reference","title":"OpenStreetMapX.SPEED_ROADS_URBAN","text":"Default Speed Limits in Kilometers Per Hour in urban areas\n\n\n\n\n\n","category":"constant"},{"location":"reference/#OpenStreetMapX.SPEED_ROADS_RURAL","page":"Reference","title":"OpenStreetMapX.SPEED_ROADS_RURAL","text":"Default Speed Limits in Kilometers Per Hour in rural areas\n\n\n\n\n\n","category":"constant"},{"location":"reference/#Map-objects","page":"Reference","title":"Map objects","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Way\nRelation","category":"page"},{"location":"reference/#OpenStreetMapX.Way","page":"Reference","title":"OpenStreetMapX.Way","text":"Ways in OSM data\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenStreetMapX.Relation","page":"Reference","title":"OpenStreetMapX.Relation","text":"Relations in OSM data\n\n\n\n\n\n","category":"type"},{"location":"reference/#Internal-library-functions","page":"Reference","title":"Internal library functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"boundary_point\ncentroid\nclassify_cycleways\nclassify_walkways\ncrop!\nextract_highways\nfeatures_to_graph\nfilter_cycleways\nfilter_highways\nfilter_walkways\nfind_intersections\nfind_optimal_waypoint_approx\nfind_optimal_waypoint_exact\nfind_route\nfind_segments","category":"page"},{"location":"reference/#OpenStreetMapX.boundary_point","page":"Reference","title":"OpenStreetMapX.boundary_point","text":"boundary_point(p1::T, p2::T, bounds::Bounds{T}) where T<:Union{LLA,ENU}\n\nFind the closest point within bounds Works only for points where inbounds(p1) != inbounds(p2)\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.centroid","page":"Reference","title":"OpenStreetMapX.centroid","text":"centroid(nodes::Dict{Int,T}, node_list::Vector{Int}) where T<:(Union{OpenStreetMapX.LLA,OpenStreetMapX.ENU})\n\nCompute Centroid of List of Nodes\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.classify_cycleways","page":"Reference","title":"OpenStreetMapX.classify_cycleways","text":"classify_cycleways(ways::Vector{OpenStreetMapX.Way},\n                   classes::Dict{String, Int} = OpenStreetMapX.CYCLE_CLASSES)\n\nClassifies a vector of OpenStreetMapX ways based on their cycleway attributes. It considers the presence of \"bicycle\", \"cycleway\", and \"highway\" tags and checks if the corresponding values or the constructed class strings are present in the specified classes dictionary.\n\nArguments\n\nways::Vector{OpenStreetMapX.Way} : Way's vector\nclasses : classes dictionary\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.classify_walkways","page":"Reference","title":"OpenStreetMapX.classify_walkways","text":"classify_walkways(ways::Vector{OpenStreetMapX.Way},\n                  classes::Dict{String, Int} = OpenStreetMapX.PED_CLASSES)\n\nClassifies a vector of OpenStreetMapX ways based on their pedestrian attributes. It considers the presence of a \"sidewalk\" tagand checks if the corresponding value or the \"highway\" tag value is present in the specified classes dictionary\n\nArguments\n\nways::Vector{OpenStreetMapX.Way} : Way's vector\nclasses : classes dictionary\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.crop!","page":"Reference","title":"OpenStreetMapX.crop!","text":"crop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, way::OpenStreetMapX.Way)\n\nCrop Single Way\n\n\n\n\n\ncrop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, ways::Vector{OpenStreetMapX.Way})\n\nCrop Ways\n\n\n\n\n\ncrop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, ways::Vector{OpenStreetMapX.Way},relations::Vector{OpenStreetMapX.Relation}, relation::OpenStreetMapX.Relation)\n\nCrop Single Relation\n\n\n\n\n\ncrop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, ways::Vector{OpenStreetMapX.Way}, relations::Vector{OpenStreetMapX.Relation})\n\nCrop Relations\n\n\n\n\n\ncrop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, features::Dict, id::Int)\n\nCrop Single Node and Feature\n\n\n\n\n\ncrop!(nodes::Dict, bounds::OpenStreetMapX.Bounds, features::Dict)\n\nCrop Nodes and Features\n\n\n\n\n\ncrop!(map::OpenStreetMapX.OSMData; crop_relations = true, crop_ways = true, crop_nodes = true)\n\nCrop Map\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.extract_highways","page":"Reference","title":"OpenStreetMapX.extract_highways","text":"\"\"     extract_highways(ways::Vector{OpenStreetMapX.Way})\n\nExtract Highways\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.features_to_graph","page":"Reference","title":"OpenStreetMapX.features_to_graph","text":"For Each Feature Find the Nearest Graph Node ###\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.filter_cycleways","page":"Reference","title":"OpenStreetMapX.filter_cycleways","text":"filter_cycleways(ways::Vector{OpenStreetMapX.Way},\n                classes::Dict{String, Int} = OpenStreetMapX.CYCLE_CLASSES;\n                levels::Set{Int} = Set(1:length(OpenStreetMapX.CYCLE_CLASSES)))\n\nFilters a vector of OpenStreetMapX ways to include only those that are relevant for cycleways. It considers the presence of \"bicycle\", \"cycleway\", and \"highway\" tags and checks if the corresponding values or the constructed class strings are present in the specified classes dictionary and levels set.\n\nArguments\n\nways::Vector{OpenStreetMapX.Way} : Way's vector\nclasses : classes dictionary\nlevels : set of levels useful to compare with the way tags\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.filter_highways","page":"Reference","title":"OpenStreetMapX.filter_highways","text":"filter_highways(ways::Vector{OpenStreetMapX.Way})\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.filter_walkways","page":"Reference","title":"OpenStreetMapX.filter_walkways","text":"filter_walkways(ways::Vector{OpenStreetMapX.Way},\n                classes::Dict{String, Int} = OpenStreetMapX.PED_CLASSES;\n                levels::Set{Int} = Set(1:length(OpenStreetMapX.PED_CLASSES)))\n\nFilters a vector of ways to include only those that are relevant for pedestrian walkways. It considers the presence of a \"sidewalk\" tag and checks if the corresponding value or the \"highway\" tag value is present in the specified classes dictionary and levels set.\n\nArguments\n\nways::Vector{OpenStreetMapX.Way} : Way's vector\nclasses : classes dictionary\nlevels : set of levels useful to compare with the way tags\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.find_intersections","page":"Reference","title":"OpenStreetMapX.find_intersections","text":"find_intersections(highways::Vector{OpenStreetMapX.Way})\n\nFind Intersections of Highways\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.find_optimal_waypoint_approx","page":"Reference","title":"OpenStreetMapX.find_optimal_waypoint_approx","text":"find_optimal_waypoint_approx(m::MapData, weights::SparseArrays.SparseMatrixCSC{Float64,Int64}, node0::Int, node1::Int, waypoints::Dict{Int,Int})\n\nFind waypoint minimizing the route. Returns an approximate solution.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.find_optimal_waypoint_exact","page":"Reference","title":"OpenStreetMapX.find_optimal_waypoint_exact","text":"find_optimal_waypoint_exact(m::MapData, weights::SparseArrays.SparseMatrixCSC{Float64,Int64}, node0::Int, node1::Int, waypoints::Dict{Int,Int})\n\nFind  waypoint minimizing the route. Returns an exact solution.\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.find_route","page":"Reference","title":"OpenStreetMapX.find_route","text":"find_route(m::MapData, node0::Int, node1::Int, node2::Int,\n                    weights::SparseArrays.SparseMatrixCSC{Float64,Int64};\n                    routing::Symbol = :astar, heuristic::Function = (u,v) -> zero(Float64),\n                    get_distance::Bool = false, get_time::Bool = false)\n\nFind Route Connecting 3 Points (node0, node1, node2) with Given Weights\n\n\n\n\n\n","category":"function"},{"location":"reference/#OpenStreetMapX.find_segments","page":"Reference","title":"OpenStreetMapX.find_segments","text":"find_segments(nodes::Dict{Int,T}, highways::Vector{OpenStreetMapX.Way}, intersections::Dict{Int,Set{Int}}) where T<:Union{OpenStreetMapX.ENU,OpenStreetMapX.ECEF}\n\nFind Segments of Highways\n\n\n\n\n\n","category":"function"},{"location":"#OpenStreetMapX.jl","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"","category":"section"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"Documentation for OpenStreetMapX.jl","category":"page"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"For details please go to the Reference section.","category":"page"},{"location":"#Package-features","page":"OpenStreetMapX.jl","title":"Package features","text":"","category":"section"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"Parse an OpenStreetMap XML datafile (OSM files)\nCrop maps to specified boundaries\nConvert maps between LLA, ECEF, and ENU coordinates\nExtract highways, buildings, and tagged features from OSM data\nCompute shortest or fastest driving, cycling, and walking routes using Julia's LightGraphs.jl package including various systems for weighting travel speed\nUse OpenStreetMapXPlot to draw maps using either Julia's PyPlot.jl or Plots.jl with GR backend packages\nIntegrate with Python folium (via PyCall.jl) to create interactive map plots","category":"page"},{"location":"","page":"OpenStreetMapX.jl","title":"OpenStreetMapX.jl","text":"For details please go to the Reference section.","category":"page"}]
}
